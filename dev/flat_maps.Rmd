---
title: "flat_maps.Rmd"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```


# fct_build_and_save_basemap

```{r development-fct_build_and_save_basemap}
# Prepare the code of your function here
```

```{r function-fct_build_and_save_basemap}
#' Create and save OpenStreetMap base map for an estuary
#'
#' @param data Data frame containing latitude and longitude
#' @param estuary_name Character name of estuary (used for folder name)
#' @param villes_selection Character vector of city names to keep (optional)
#' @param path Base path for saving (default: inst/extdata)
#'
#' @return A list with map components (also saved on disk)
#'
#' @import dplyr
#' @importFrom sf st_as_sf st_bbox st_polygon st_sf st_sfc
#' @importFrom sf st_intersection st_distance st_write
#' @importFrom osmdata opq add_osm_feature osmdata_sf
#' @importFrom maptiles get_tiles
#' @importFrom terra writeRaster
#' @export
fct_build_and_save_basemap <- function(data,
                                       estuary_name,
                                       villes_selection = NULL,
                                       path = "inst/extdata") {

  # -------------------------
  # 0. Charger halin_table du package
  # -------------------------
  if (!exists("halin_table")) {
    stop("halin_table not found in the package")
  }

  halin_values <- halin_table[halin_table$estuary == estuary_name, ]
  halin_limit_lat <- halin_values$halin_limit_lat
  halin_limit_lon <- halin_values$halin_limit_lon
  
  # -------------------------
  # 1. Convert to sf
  # -------------------------
  points_sf <- data |>
    dplyr::filter(!is.na(latitude) & !is.na(longitude)) |>
    sf::st_as_sf(
      coords = c("longitude", "latitude"),
      crs = 4326,
      remove = FALSE
    )

  # -------------------------
  # 2. Bounding box + buffer
  # -------------------------
  bbox <- sf::st_bbox(points_sf)
  buffer_deg <- 0.02

  xlim <- c(bbox["xmin"] - buffer_deg,
            bbox["xmax"] + buffer_deg)

  ylim <- c(bbox["ymin"] - buffer_deg,
            bbox["ymax"] + buffer_deg)

  coords <- matrix(
    c(
      xlim[1], ylim[1],
      xlim[1], ylim[2],
      xlim[2], ylim[2],
      xlim[2], ylim[1],
      xlim[1], ylim[1]
    ),
    ncol = 2,
    byrow = TRUE
  )

  poly <- sf::st_polygon(list(coords))
  bbox_sf <- sf::st_sf(
    geometry = sf::st_sfc(poly, crs = 4326)
  )

  bbox_vector <- c(
    xmin = xlim[1],
    ymin = ylim[1],
    xmax = xlim[2],
    ymax = ylim[2]
  )

  # -------------------------
  # 3. OSM cities
  # -------------------------
  villes_osm <- osmdata::opq(bbox = bbox_vector) |>
    osmdata::add_osm_feature(
      key = "place",
      value = c("city", "town", "village")
    ) |>
    osmdata::osmdata_sf()

  villes_points <- villes_osm$osm_points

  if (!is.null(villes_points) && nrow(villes_points) > 0) {

    villes_points <- sf::st_intersection(
      villes_points,
      sf::st_as_sfc(sf::st_bbox(points_sf))
    )

    # -------------------------
    #  Filtrage par noms fournis
    # -------------------------
    if (!is.null(villes_selection)) {

      villes_points <- villes_points |>
        dplyr::filter(name %in% villes_selection)

      # message si certaines villes absentes
      villes_manquantes <- setdiff(villes_selection,
                                   unique(villes_points$name))

      if (length(villes_manquantes) > 0) {
        warning("These cities were not found in OSM data: ",
                paste(villes_manquantes, collapse = ", "))
      }
    }

    villes_finales <- villes_points

  } else {
    villes_finales <- NULL
  }

  # -------------------------
  # 4. Download OSM raster
  # -------------------------
  osm_raster <- maptiles::get_tiles(
    bbox_sf,
    provider = "OpenStreetMap",
    crop = TRUE
  )

  # matérialisation pour éviter external pointer
  osm_raster <- terra::writeRaster(
    osm_raster,
    filename = tempfile(fileext = ".tif"),
    overwrite = TRUE
  )

  # -------------------------
  # 5. Save to package
  # -------------------------
  dir_estuary <- file.path(path, estuary_name)
  dir.create(dir_estuary,
             recursive = TRUE,
             showWarnings = FALSE)

  terra::writeRaster(
    osm_raster,
    filename = file.path(dir_estuary, "osm.tif"),
    overwrite = TRUE
  )

  if (!is.null(villes_finales)) {
    sf::st_write(
      villes_finales,
      file.path(dir_estuary, "villes.gpkg"),
      delete_dsn = TRUE,
      quiet = TRUE
    )
  }

  saveRDS(
    list(xlim = xlim, ylim = ylim,
         halin_limit_lat = halin_limit_lat,
         halin_limit_lon = halin_limit_lon),
    file.path(dir_estuary, "bbox.rds")
  )

  # -------------------------
  # 6. Return object
  # -------------------------
  return(list(
    points_sf = points_sf,
    osm_raster = osm_raster,
    villes = villes_finales,
    xlim = xlim,
    ylim = ylim,
    halin_limit_lat = halin_limit_lat,
    halin_limit_lon = halin_limit_lon
  ))
}
```

  
```{r example-fct_build_and_save_basemap}
# fct_build_and_save_basemap(
#   data = data_loire,
#   estuary_name = "loire",
#   villes_selection = c("Saint-Nazaire",
#                        "Pornic",
#                        "Le Croisic")
# )
```
    
# load_estuary_basemap

```{r function-load_estuary_basemap}
#' Load estuary basemap (OpenStreetMap)
#' 
#' @param estuary_name Character name of estuary
#' @param package Name of package (default = "esteem.overview")
#'
#' @return List containing osm_raster, villes, xlim, ylim
#' 
#' @export
load_estuary_basemap <- function(estuary_name,
                                 package = "esteem.overview") {

  base_path <- system.file("extdata",
                           estuary_name,
                           package = package)

  if (base_path == "") {
    stop("Estuary not found in package extdata/")
  }

  # Raster
  osm_raster_path <- file.path(base_path, "osm.tif")

  if (!file.exists(osm_raster_path)) {
    stop("osm.tif not found for this estuary.")
  }

  osm_raster <- terra::rast(osm_raster_path)

  # Cities
  villes_path <- file.path(base_path, "villes.gpkg")

  if (file.exists(villes_path)) {
    villes <- sf::st_read(villes_path, quiet = TRUE)
  } else {
    villes <- NULL
  }

  # Bbox
  bbox_path <- file.path(base_path, "bbox.rds")

  if (!file.exists(bbox_path)) {
    stop("bbox.rds not found for this estuary.")
  }

  bbox <- readRDS(bbox_path)

  return(list(
    osm_raster = osm_raster,
    villes = villes,
    xlim = bbox$xlim,
    ylim = bbox$ylim,
    halin_limit_lat = bbox$halin_limit_lat,
    halin_limit_lon = bbox$halin_limit_lon
  ))
}
```
  
```{r example-load_estuary_basemap}
basemap <- load_estuary_basemap(estuary_name = "Loire" )
# 
# ggplot() +
#   tidyterra::geom_spatraster_rgb(data = basemap$osm_raster) +
#   geom_sf(data = basemap$villes) +
#   coord_sf(xlim = basemap$xlim,
#            ylim = basemap$ylim,
#            expand = FALSE)
```

# plot_estuary_map

```{r function-plot_estuary_map}
#' Plot estuary map with points, optional variable mapping and optional horizontal/vertical lines
#'
#' @param data Data frame containing latitude and longitude
#' @param estuary_name Character name of the estuary
#' @param colour_var Optional variable in `data` for point colour
#' @param fill_var Optional variable in `data` for point fill (shape 21)
#' @param size_var Optional variable in `data` for point size
#' @param shape_var Optional variable in `data` for point shape
#' @param package Package name where basemap is stored (default: "esteem.overview")
#'
#'
#' @import dplyr
#' @import ggplot2
#' @importFrom ggspatial annotation_scale
#' @importFrom ggspatial annotation_north_arrow
#' @importFrom ggspatial north_arrow_orienteering
#' @importFrom ggrepel geom_text_repel
#' @importFrom tidyterra geom_spatraster_rgb
#' @importFrom rlang ensym
#' @importFrom rlang sym
#' @importFrom sf st_as_sf
#' @importFrom sf st_coordinates
#' @importFrom rlang enquo quo_is_null
#' 
#' @return ggplot object
#' @export
plot_estuary_map <- function(data,
                             estuary_name,
                             colour_var,
                             fill_var,
                             size_var,
                             shape_var,
                             package = "esteem.overview") {

  # -------------------------
  # 1. Load basemap
  # -------------------------
  basemap <- load_estuary_basemap(estuary_name,
                                  package = package)

  # -------------------------
  # 2. Convert data to sf
  # -------------------------
  points_sf <- make_points_sf(data)

  # -------------------------
  # 3. Base plot
  # -------------------------
  p <- ggplot2::ggplot() +
    tidyterra::geom_spatraster_rgb(data = basemap$osm_raster)

  # -------------------------
  # 4. Dynamic aesthetic mapping
  # -------------------------
  
  # Capture arguments
  colour_var <- rlang::enquo(colour_var)
  fill_var   <- rlang::enquo(fill_var)
  size_var   <- rlang::enquo(size_var)
  shape_var  <- rlang::enquo(shape_var)
  
mapping <- list()

if (!missing(colour_var)) {
  colour_var <- rlang::enquo(colour_var)
  mapping$colour <- colour_var
}

if (!missing(fill_var)) {
  fill_var <- rlang::enquo(fill_var)
  mapping$fill <- fill_var
}

if (!missing(size_var)) {
  size_var <- rlang::enquo(size_var)
  mapping$size <- size_var
}

if (!missing(shape_var)) {
  shape_var <- rlang::enquo(shape_var)
  mapping$shape <- shape_var
}
  
if (length(mapping) > 0) {

  # Shape automatique si pas fourni
  geom_shape <- NULL
  if (!"shape" %in% names(mapping)) {
    if ("fill" %in% names(mapping)) {
      geom_shape <- 21
    } else {
      geom_shape <- 19
    }
  }

  if (is.null(geom_shape)) {

    # PAS de shape dans geom_sf
    p <- p + ggplot2::geom_sf(
      data = points_sf,
      mapping = do.call(ggplot2::aes, mapping),
      alpha = 0.8
    )

  } else {

    # shape explicite
    p <- p + ggplot2::geom_sf(
      data = points_sf,
      mapping = do.call(ggplot2::aes, mapping),
      shape = geom_shape,
      alpha = 0.8
    )
  }

} else {

  p <- p + ggplot2::geom_sf(
    data = points_sf,
    size = 2,
    alpha = 0.8
  )
}
  
  # -------------------------
  # 5. Cities + labels
  # -------------------------
  if (!is.null(basemap$villes) && nrow(basemap$villes) > 0) {
    # Points des villes
    p <- p + ggplot2::geom_sf(
      data = basemap$villes,
      shape = 21,
      fill = "black",
      color = "black",
      size = 3
    )
    
     # Convertir coordonnées pour labels
  villes_coords <- cbind(
    basemap$villes,
    sf::st_coordinates(basemap$villes)
  )
  
    # Labels des villes
  p <- p + ggrepel::geom_text_repel(
    data = villes_coords,
    aes(x = X, y = Y, label = name),
    min.segment.length = 0,
    nudge_y = 0.01,            # décale légèrement le texte
    size = 3,
    color = "black",
    text_family = "sans"
  )
  }

  # -------------------------
  # 6. Ajouter lignes horizontales/verticales si définies
  # -------------------------

# Ligne horizontale
if (!is.null(basemap$halin_limit_lat) && !is.na(basemap$halin_limit_lat)) {
  p <- p + ggplot2::geom_segment(
    data = data.frame(
      x = basemap$xlim[1],
      xend = basemap$xlim[2],
      y = basemap$halin_limit_lat,
      yend = basemap$halin_limit_lat
    ),
    ggplot2::aes(x = x, xend = xend, y = y, yend = yend),
    color = "black",
    linewidth = 1.2
  )
}

# Ligne verticale
if (!is.null(basemap$halin_limit_lon) && !is.na(basemap$halin_limit_lon)) {
  p <- p + ggplot2::geom_segment(
    data = data.frame(
      x = basemap$halin_limit_lon,
      xend = basemap$halin_limit_lon,
      y = basemap$ylim[1],
      yend = basemap$ylim[2]
    ),
    ggplot2::aes(x = x, xend = xend, y = y, yend = yend),
    color = "black",
    linewidth = 1.2
  )
}

  # -------------------------
  # 7. Coordinates + theme
  # -------------------------
  p <- p +
    ggplot2::coord_sf(
      xlim = basemap$xlim,
      ylim = basemap$ylim,
      expand = FALSE
    ) +
    theme_esteem() +
    ggplot2::theme(
      axis.title = ggplot2::element_blank()
    )

  # -------------------------
  # 8. Scale bar + north arrow + title
  # -------------------------
  p <- p +
  ggspatial::annotation_scale(
    location = "bl",      # bas gauche
    width_hint = 0.2,     # proportion de la carte
    text_cex = 1,         # taille du texte
    text_family = "sans"
  ) +
  ggspatial::annotation_north_arrow(
    pad_x = unit(0.5, "cm"), # décale horizontalement
    pad_y = unit(0.7, "cm"), # décale verticalement
    which_north = "true",
    style = ggspatial::north_arrow_orienteering(),
    height = grid::unit(0.5, "cm"),   # hauteur totale de la flèche
    width  = grid::unit(0.5, "cm"),  # largeur
    text_family = "sans"
  ) +
  ggplot2::labs(title = paste0(estuary_name, " estuary"))
    
    
  return(p)
}
```
  
```{r example-plot_estuary_map}
# plot_estuary_map(
#   data = data_POMET |> filter(estuary == "Gironde"),
#   estuary_name = "Gironde",
#   colour_var = salinite,
# )
```
  
```{r tests-plot_estuary_map}
```
  

# Inflate

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_maps.Rmd", 
               vignette_name = NULL, check = FALSE)
```

