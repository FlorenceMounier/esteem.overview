---
title: "flat_data_contamination.Rmd"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(here)
library(segmented)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# fun_seg_model
    
```{r development-fun_seg_model}
# You can prepare the code of the fun_seg_model() function here
```
  
```{r function-fun_seg_model}
#' Title
#' 
#' Description
#' 
#' @return
#' 
#' @export
fun_seg_model <- function(data, estuary, chemical, folder = "metals", n_break = 1, plot_save = TRUE){
      
  # Data filtering
  data_estuary_chemical <- data |>  filter(ESTUARY == estuary, PARAMETRE_LIBELLE == chemical)
  
  # Segmented model
  lm_model <- lm(data = data_estuary_chemical, RESULTAT ~ YEAR)
  seg_model <- segmented(lm_model, seg.Z = ~ YEAR, npsi = n_break)
    # summary(seg_model) ## identifies the inflection point and tests whether the model is significant
    # anova(seg_model) ## allows us to see if the inflection is significant
    # slope(seg_model) ## details the slopes
  
  # Put into a data.frame
  slope_df <- slope(seg_model)$YEAR |> as.data.frame()
  colnames(slope_df) <- c("Estimate", "StdErr", "t_value", "CI_lower", "CI_upper")
  rownames(slope_df) <- paste0("Segment ", seq_len(nrow(slope_df)))
  # Calculation of the two-sided p-value
  slope_df$p_value <- 2 * pt(-abs(slope_df$t_value), df = df.residual(seg_model))
  # Breakpoint recovery and conversion to Date
  break_dates <- seg_model$psi[, "Est."]
  # Create segment terminals
  segment_start <- c(min(data_estuary_chemical$YEAR), break_dates)
  segment_end   <- c(break_dates, max(data_estuary_chemical$YEAR))
  # Middle of each segment
  slope_df$mid_date <- (as.numeric(segment_start) + as.numeric(segment_end)) / 2
  # Label text for each segment
  slope_df$label <- paste0(
    "β = ", round(slope_df$Estimate, 3),
    " [", round(slope_df$CI_lower, 3),
    "; ", round(slope_df$CI_upper, 3),
    "] µg/gdw / y", "\n",
    ifelse(slope_df$p_value < 0.05, "p < 0.05", paste0("p = ", signif(slope_df$p_value, 6)))
  )
  
  # Build ggplot
  plot <- ggplot(data_estuary_chemical) +
    aes(x = YEAR, y = RESULTAT) +
    geom_line() +
    geom_line(aes(y = fitted(seg_model)), color = "blue") +
    geom_vline(xintercept = break_dates,
               linetype = "dashed",
               color = "blue") +
    geom_text(data = slope_df,
              aes(x = mid_date, y = max(data_estuary_chemical$RESULTAT), label = label),
      vjust = -0.5, color = "darkgreen", size = 3.5) +
    expand_limits(y = max(data_estuary_chemical$RESULTAT, na.rm = TRUE) * 1.1) +
    labs(title = paste0("Changes in ", chemical, " contamination in the ", estuary, " estuary"),
         x = NULL, y = paste0("Concentration in ", unique(data_estuary_chemical$UNITE)))
  
  # Plot saving
  if(plot_save == TRUE){
      filename <- paste0("segmented_models/ggplot_", chemical, "_", estuary, ".png")
  ggsave(plot = plot, filename = here("inst/results/data_contam/", folder, filename), width = 20, height = 15, units = "cm")
  } else {}

  
  # Output table
  res_trends <- tibble(
    ESTUARY = estuary,
    PARAMETRE_LIBELLE = chemical,
    break_dates = break_dates[length(break_dates)],
    last_p_value = slope_df$p_value[length(slope_df$p_value)],
    last_slope = slope_df$Estimate[length(slope_df$Estimate)]
  )
  
  # add tendency depending on p-value and slope of last period of segmented models
  res_trends <- res_trends |> 
      mutate(symbol = case_when(
    last_p_value > 0.05 ~ "\u2192",
    last_slope > 0 ~ "↑",
    last_slope < 0 ~ "↓",
    TRUE ~ NA
  ))
  
  # extract last year and last value for each ESTUARY, PARAMETRE_LIBELLE
  last_points <- data_estuary_chemical |>
    group_by(ESTUARY, PARAMETRE_LIBELLE) |>
    summarise(
      last_year = max(YEAR),
      last_resultat = median(RESULTAT[which(YEAR == max(YEAR))]),
      .groups = "drop"
    )
  
  trends <- left_join(res_trends, last_points)
  
  return(trends)
}
```
  
```{r example-fun_seg_model}
# fun_seg_model()
```
  
```{r tests-fun_seg_model}
test_that("fun_seg_model works", {
  expect_true(inherits(fun_seg_model, "function")) 
})
```


# get_kruskal_periods_results
    
```{r development-get_kruskal_periods_results}
# You can prepare the code of the get_kruskal_periods_results() function here
```
  
```{r function-get_kruskal_periods_results}
#' Get results of Kruskal-Wallis test between two periods of time
#' 
#' Get all information of Kruskal-Wallis test by PARAMETRE_LIBELLE and ESTUARY to be plotted
#' 
#' @param data_with_periode Dataset with columns ESTUARY, PARAMETRE_LIBELLE, RESULTAT, periode
#' @param chemicals vector of existing values in PARAMETRE_LIBELLE
#' @param estuaries vector of existing values in ESTUARY
#'
#' @return tibble containing, ESTUARY, PARAMETRE_LIBELLE, pvalue, median_1 (first period), median_2 (last period), max_value, trend (symbol to be plotted), y_pos (y position to be plotted)
#' 
#' @export
get_kruskal_periods_results <- function(data_with_periode, chemicals, 
                                         estuaries = c("Gironde", "Loire", "Seine")){
  
  # Create an empty tibble
  res_kruskal_periode <- tibble(ESTUARY = NA, PARAMETRE_LIBELLE = NA, pvalue = NA, 
                                 median_1 = NA, median_2 = NA, max_value = NA)
  
  for(chem in 1:length(chemicals)) {
    for (est in 1:length(estuaries)) {
      name_estuary <- estuaries[est]
      name_chemical <- chemicals[chem]
      # Filter data for a given estuary X chemical
      data_filtered <- data_with_periode |> 
        filter(PARAMETRE_LIBELLE == name_chemical, ESTUARY == name_estuary) |> 
        drop_na(periode)
      # Max value
      max_value = signif(max(data_filtered$RESULTAT), digits = 3)
      # Compute median values for the first and last period
      res_median <- data_filtered |> 
        group_by(periode) |> 
        summarise(median = median(RESULTAT) |> signif(4))
      # Test median difference
      kruskal_pvalue <- signif(kruskal.test(data_filtered$RESULTAT, data_filtered$periode)[["p.value"]], digits = 3)
      # Save results in the tibble
      res_kruskal_periode <- rbind(
        res_kruskal_periode,
        c(name_estuary, name_chemical, kruskal_pvalue, res_median$median, max_value)
      )
    }
  }
  # Get rid of the first line of the tibble created at its initialisation
  res_kruskal_periode <- res_kruskal_periode |> drop_na()
  
  # Mutate median columns to numerical and compute max median
  res_kruskal_periode <- res_kruskal_periode |> 
    mutate(median_1 = as.numeric(median_1),
           median_2 = as.numeric(median_2),
           max_value = as.numeric(max_value))
  
  # Get trend symbol
  res_kruskal_periode <- res_kruskal_periode |>
    mutate(
      trend = case_when(
        pvalue > 0.05 ~ "\u2192",
        median_1 > median_2 ~ "↓",
        median_2 > median_1 ~ "↑",
        TRUE ~ NA
      )
    )
  
  # Get max value by PARAMETRE_LIBELLE
  res_kruskal_periode <- res_kruskal_periode |>
    group_by(PARAMETRE_LIBELLE) |> 
    mutate(y_pos = max(max_value)) |> 
    ungroup()
  
  # Return tibble
  return(res_kruskal_periode)
}
```
  
```{r example-get_kruskal_periods_results}
# get_kruskal_periods_results()
```
  
```{r tests-get_kruskal_periods_results}
test_that("get_kruskal_periods_results works", {
  expect_true(inherits(get_kruskal_periods_results, "function")) 
})
```
  

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_data_contamination.Rmd", vignette_name = NULL, check = FALSE)
```

