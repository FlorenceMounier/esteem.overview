# WARNING - Generated by {fusen} from dev/flat_fct_build_and_save_basemap.Rmd: do not edit by hand # nolint: line_length_linter.

#' Create and save OpenStreetMap base map for an estuary
#'
#' @param data Data frame containing pos_lat_dd and pos_long_dd
#' @param estuary_name Character name of estuary (used for folder name)
#' @param villes_selection Character vector of city names to keep (optional)
#' @param path Base path for saving (default: inst/extdata)
#'
#' @return A list with map components (also saved on disk)
#'
#' @import dplyr
#' @importFrom sf st_as_sf st_bbox st_polygon st_sf st_sfc
#' @importFrom sf st_intersection st_distance st_write
#' @importFrom osmdata opq add_osm_feature osmdata_sf
#' @importFrom maptiles get_tiles
#' @importFrom terra writeRaster
#' @export
#' @examples
#' # fct_build_and_save_basemap(
#' #   data = data_loire,
#' #   estuary_name = "loire",
#' #   villes_selection = c("Saint-Nazaire",
#' #                        "Pornic",
#' #                        "Le Croisic")
#' # )
fct_build_and_save_basemap <- function(data,
                                       estuary_name,
                                       villes_selection = NULL,
                                       path = "inst/extdata") {

  # -------------------------
  # 0. Charger halin_table du package
  # -------------------------
  if (!exists("halin_table")) {
    stop("halin_table not found in the package")
  }

  halin_values <- halin_table[halin_table$estuary == estuary_name, ]
  halin_limit_lat <- halin_values$halin_limit_lat
  halin_limit_lon <- halin_values$halin_limit_lon
  
  # -------------------------
  # 1. Convert to sf
  # -------------------------
  points_sf <- data |>
    dplyr::filter(!is.na(pos_lat_dd) & !is.na(pos_long_dd)) |>
    sf::st_as_sf(
      coords = c("pos_long_dd", "pos_lat_dd"),
      crs = 4326,
      remove = FALSE
    )

  # -------------------------
  # 2. Bounding box + buffer
  # -------------------------
  bbox <- sf::st_bbox(points_sf)
  buffer_deg <- 0.02

  xlim <- c(bbox["xmin"] - buffer_deg,
            bbox["xmax"] + buffer_deg)

  ylim <- c(bbox["ymin"] - buffer_deg,
            bbox["ymax"] + buffer_deg)

  coords <- matrix(
    c(
      xlim[1], ylim[1],
      xlim[1], ylim[2],
      xlim[2], ylim[2],
      xlim[2], ylim[1],
      xlim[1], ylim[1]
    ),
    ncol = 2,
    byrow = TRUE
  )

  poly <- sf::st_polygon(list(coords))
  bbox_sf <- sf::st_sf(
    geometry = sf::st_sfc(poly, crs = 4326)
  )

  bbox_vector <- c(
    xmin = xlim[1],
    ymin = ylim[1],
    xmax = xlim[2],
    ymax = ylim[2]
  )

  # -------------------------
  # 3. OSM cities
  # -------------------------
  villes_osm <- osmdata::opq(bbox = bbox_vector) |>
    osmdata::add_osm_feature(
      key = "place",
      value = c("city", "town", "village")
    ) |>
    osmdata::osmdata_sf()

  villes_points <- villes_osm$osm_points

  if (!is.null(villes_points) && nrow(villes_points) > 0) {

    villes_points <- sf::st_intersection(
      villes_points,
      sf::st_as_sfc(sf::st_bbox(points_sf))
    )

    # -------------------------
    #  Filtrage par noms fournis
    # -------------------------
    if (!is.null(villes_selection)) {

      villes_points <- villes_points |>
        dplyr::filter(name %in% villes_selection)

      # message si certaines villes absentes
      villes_manquantes <- setdiff(villes_selection,
                                   unique(villes_points$name))

      if (length(villes_manquantes) > 0) {
        warning("These cities were not found in OSM data: ",
                paste(villes_manquantes, collapse = ", "))
      }
    }

    villes_finales <- villes_points

  } else {
    villes_finales <- NULL
  }

  # -------------------------
  # 4. Download OSM raster
  # -------------------------
  osm_raster <- maptiles::get_tiles(
    bbox_sf,
    provider = "OpenStreetMap",
    crop = TRUE
  )

  # matérialisation pour éviter external pointer
  osm_raster <- terra::writeRaster(
    osm_raster,
    filename = tempfile(fileext = ".tif"),
    overwrite = TRUE
  )

  # -------------------------
  # 5. Save to package
  # -------------------------
  dir_estuary <- file.path(path, estuary_name)
  dir.create(dir_estuary,
             recursive = TRUE,
             showWarnings = FALSE)

  terra::writeRaster(
    osm_raster,
    filename = file.path(dir_estuary, "osm.tif"),
    overwrite = TRUE
  )

  if (!is.null(villes_finales)) {
    sf::st_write(
      villes_finales,
      file.path(dir_estuary, "villes.gpkg"),
      delete_dsn = TRUE,
      quiet = TRUE
    )
  }

  saveRDS(
    list(xlim = xlim, ylim = ylim,
         halin_limit_lat = halin_limit_lat,
         halin_limit_lon = halin_limit_lon),
    file.path(dir_estuary, "bbox.rds")
  )

  # -------------------------
  # 6. Return object
  # -------------------------
  return(list(
    points_sf = points_sf,
    osm_raster = osm_raster,
    villes = villes_finales,
    xlim = xlim,
    ylim = ylim,
    halin_limit_lat = halin_limit_lat,
    halin_limit_lon = halin_limit_lon
  ))
}
