# WARNING - Generated by {fusen} from dev/flat_fct_openstreet_base_map.Rmd: do not edit by hand # nolint: line_length_linter.

#' Create OpenStreetMap base map for a given region
#'
#' @param data 
#'
#' @return 1
#' 
#' @import dplyr
#' @importFrom sf st_as_sf
#' @importFrom sf st_bbox
#' @importFrom sf st_polygon
#' @importFrom sf st_sf
#' @importFrom sf st_intersection
#' @importFrom sf st_distance
#' @importFrom osmdata opq
#' @importFrom osmdata add_osm_feature
#' @importFrom osmdata osmdata_sf
#' @importFrom maptiles get_tiles
#' 
#' @export
#'
fct_openstreet_base_map <- function(data){

  # points sf
  points_sf <- data |>
    filter(!is.na(pos_lat_dd) & !is.na(pos_long_dd)) |>
    st_as_sf(
      coords = c("pos_long_dd", "pos_lat_dd"),
      crs = 4326,
      remove = FALSE
    )

  # bbox simple + buffer manuel en degrés (~5 km)
  bbox <- st_bbox(points_sf)

  # On crée un rectangle polygonal propre
  buffer_deg <- 0.02  # ~5 km

  xlim <- c(bbox["xmin"] - buffer_deg, bbox["xmax"] + buffer_deg)
  ylim <- c(bbox["ymin"] - buffer_deg, bbox["ymax"] + buffer_deg)

  coords <- matrix(
    c(
      bbox["xmin"] - buffer_deg, bbox["ymin"] - buffer_deg,
      bbox["xmin"] - buffer_deg, bbox["ymax"] + buffer_deg,
      bbox["xmax"] + buffer_deg, bbox["ymax"] + buffer_deg,
      bbox["xmax"] + buffer_deg, bbox["ymin"] - buffer_deg,
      bbox["xmin"] - buffer_deg, bbox["ymin"] - buffer_deg
    ),
    ncol = 2,
    byrow = TRUE
  )
  poly <- st_polygon(list(coords))       # crée un sfg polygon
  bbox_sf <- st_sf(geometry = st_sfc(poly, crs = 4326))  # convertit en sf polygon

  # Définir la bbox de la carte
  bbox_vector <- c(xmin = xlim[1], ymin = ylim[1], xmax = xlim[2], ymax = ylim[2])

  ## Requête Overpass : récupérer les villes (place = city ou town)
  villes_osm <- opq(bbox = bbox_vector) %>%
    add_osm_feature(key = "place", value = c("city", "town", "village")) %>%
    osmdata_sf()
    # Points des villes
  villes_points <- villes_osm$osm_points
    # Filtrer pour être sûr qu’elles sont dans notre bbox
  villes_points <- st_intersection(villes_points, st_as_sfc(st_bbox(points_sf)))
    # Requête pour les côtes (water = sea)
  cote_osm <- opq(bbox = bbox_vector, timeout = 300) %>%
    add_osm_feature(key = "natural", value = "coastline") %>%
    osmdata_sf()
    # Les côtes sont dans osm_lines
  cote_sf <- cote_osm$osm_lines
    # Distance minimale ville → côte
  dist_ville_cote <- st_distance(villes_points, cote_sf)
    # Garde seulement les villes à moins de 2 km de la côte
  villes_cotiere <- villes_points[apply(dist_ville_cote, 1, min) <= 2000, ]

  # Télécharger le fond OSM avec maptiles
  osm_raster <- get_tiles(
    bbox_sf,
    provider = "OpenStreetMap",
    crop = TRUE
  )

  result <- list(points_sf = points_sf,
                 osm_raster = osm_raster,
                 villes_cotiere = villes_cotiere,
                 xlim = xlim, ylim = ylim)

  return(result)
}
