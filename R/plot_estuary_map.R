# WARNING - Generated by {fusen} from dev/flat_maps.Rmd: do not edit by hand # nolint: line_length_linter.

#' Plot estuary map with points, optional variable mapping and optional horizontal/vertical lines
#'
#' @param data Data frame containing latitude and longitude
#' @param estuary_name Character name of the estuary
#' @param colour_var Optional variable in `data` for point colour
#' @param fill_var Optional variable in `data` for point fill (shape 21)
#' @param size_var Optional variable in `data` for point size
#' @param shape_var Optional variable in `data` for point shape
#' @param package Package name where basemap is stored (default: "esteem.overview")
#'
#'
#' @import dplyr
#' @import ggplot2
#' @importFrom ggspatial annotation_scale
#' @importFrom ggspatial annotation_north_arrow
#' @importFrom ggspatial north_arrow_orienteering
#' @importFrom ggrepel geom_text_repel
#' @importFrom tidyterra geom_spatraster_rgb
#' @importFrom rlang ensym
#' @importFrom rlang sym
#' @importFrom sf st_as_sf
#' @importFrom sf st_coordinates
#' @importFrom rlang enquo quo_is_null
#' 
#' @return ggplot object
#' @export
#' @examples
#' # plot_estuary_map(
#' #   data = data_POMET |> filter(estuary == "Gironde"),
#' #   estuary_name = "Gironde",
#' #   colour_var = salinite,
#' # )
plot_estuary_map <- function(data,
                             estuary_name,
                             colour_var,
                             fill_var,
                             size_var,
                             shape_var,
                             package = "esteem.overview") {

  # -------------------------
  # 1. Load basemap
  # -------------------------
  basemap <- load_estuary_basemap(estuary_name,
                                  package = package)

  # -------------------------
  # 2. Convert data to sf
  # -------------------------
  points_sf <- make_points_sf(data)

  # -------------------------
  # 3. Base plot
  # -------------------------
  p <- ggplot2::ggplot() +
    tidyterra::geom_spatraster_rgb(data = basemap$osm_raster)

  # -------------------------
  # 4. Dynamic aesthetic mapping
  # -------------------------
  
  # Capture arguments
  colour_var <- rlang::enquo(colour_var)
  fill_var   <- rlang::enquo(fill_var)
  size_var   <- rlang::enquo(size_var)
  shape_var  <- rlang::enquo(shape_var)
  
mapping <- list()

if (!missing(colour_var)) {
  colour_var <- rlang::enquo(colour_var)
  mapping$colour <- colour_var
}

if (!missing(fill_var)) {
  fill_var <- rlang::enquo(fill_var)
  mapping$fill <- fill_var
}

if (!missing(size_var)) {
  size_var <- rlang::enquo(size_var)
  mapping$size <- size_var
}

if (!missing(shape_var)) {
  shape_var <- rlang::enquo(shape_var)
  mapping$shape <- shape_var
}
  
if (length(mapping) > 0) {

  # Shape automatique si pas fourni
  geom_shape <- NULL
  if (!"shape" %in% names(mapping)) {
    if ("fill" %in% names(mapping)) {
      geom_shape <- 21
    } else {
      geom_shape <- 19
    }
  }

  if (is.null(geom_shape)) {

    # PAS de shape dans geom_sf
    p <- p + ggplot2::geom_sf(
      data = points_sf,
      mapping = do.call(ggplot2::aes, mapping),
      alpha = 0.8
    )

  } else {

    # shape explicite
    p <- p + ggplot2::geom_sf(
      data = points_sf,
      mapping = do.call(ggplot2::aes, mapping),
      shape = geom_shape,
      alpha = 0.8
    )
  }

} else {

  p <- p + ggplot2::geom_sf(
    data = points_sf,
    size = 2,
    alpha = 0.8
  )
}
  
  # -------------------------
  # 5. Cities + labels
  # -------------------------
  if (!is.null(basemap$villes) && nrow(basemap$villes) > 0) {
    # Points des villes
    p <- p + ggplot2::geom_sf(
      data = basemap$villes,
      shape = 21,
      fill = "black",
      color = "black",
      size = 3
    )
    
     # Convertir coordonnées pour labels
  villes_coords <- cbind(
    basemap$villes,
    sf::st_coordinates(basemap$villes)
  )
  
    # Labels des villes
  p <- p + ggrepel::geom_text_repel(
    data = villes_coords,
    aes(x = X, y = Y, label = name),
    min.segment.length = 0,
    nudge_y = 0.01,            # décale légèrement le texte
    size = 3,
    color = "black",
    text_family = "Arial"
  )
  }

  # -------------------------
  # 6. Ajouter lignes horizontales/verticales si définies
  # -------------------------

# Ligne horizontale
if (!is.null(basemap$halin_limit_lat) && !is.na(basemap$halin_limit_lat)) {
  p <- p + ggplot2::geom_segment(
    data = data.frame(
      x = basemap$xlim[1],
      xend = basemap$xlim[2],
      y = basemap$halin_limit_lat,
      yend = basemap$halin_limit_lat
    ),
    ggplot2::aes(x = x, xend = xend, y = y, yend = yend),
    color = "black",
    linewidth = 1.2
  )
}

# Ligne verticale
if (!is.null(basemap$halin_limit_lon) && !is.na(basemap$halin_limit_lon)) {
  p <- p + ggplot2::geom_segment(
    data = data.frame(
      x = basemap$halin_limit_lon,
      xend = basemap$halin_limit_lon,
      y = basemap$ylim[1],
      yend = basemap$ylim[2]
    ),
    ggplot2::aes(x = x, xend = xend, y = y, yend = yend),
    color = "black",
    linewidth = 1.2
  )
}

  # -------------------------
  # 7. Coordinates + theme
  # -------------------------
  p <- p +
    ggplot2::coord_sf(
      xlim = basemap$xlim,
      ylim = basemap$ylim,
      expand = FALSE
    ) +
    ggplot2::theme_esteem() +
    ggplot2::theme(
      axis.title = ggplot2::element_blank()
    )

  # -------------------------
  # 8. Scale bar + north arrow + title
  # -------------------------
  p <- p +
  ggspatial::annotation_scale(
    location = "bl",      # bas gauche
    width_hint = 0.2,     # proportion de la carte
    text_cex = 1,         # taille du texte
    text_family = "Arial"
  ) +
  ggspatial::annotation_north_arrow(
    pad_x = unit(0.5, "cm"), # décale horizontalement
    pad_y = unit(0.7, "cm"), # décale verticalement
    which_north = "true",
    style = ggspatial::north_arrow_orienteering(),
    height = grid::unit(0.5, "cm"),   # hauteur totale de la flèche
    width  = grid::unit(0.5, "cm"),  # largeur
    text_family = "Arial"
  ) +
  ggplot2::labs(title = paste0(estuary_name, " estuary"))
    
    
  return(p)
}
